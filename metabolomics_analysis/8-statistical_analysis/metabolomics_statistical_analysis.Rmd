---
title: "metabolomics_analysis"
author: 
- "DeniseSl22"
- "ddedesener"
date: "25/04/2022"
output:
 md_document:
    variant: markdown_github
always_allow_html: true
---

## Introduction
In this workflow, we will apply statistical analysis on metabolomics data and link the metabolites of interest to pathway data from WikiPathways.

First we locate the metabolomics data from step 7 (preprocessing).
```{r data_import,warning=FALSE, message=FALSE}
# Obtain Working Directory for step 7 to find data
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
getwd()
setwd('..')
work_DIR <- getwd()

#Obtain data from step 7
mSet_CD <- read.csv("7-data_preprocessing/output/mbxDataCD_nonIBD.csv", na.strings=c("", "NA"))
mSet_UC <- read.csv("7-data_preprocessing/output/mbxDataUC_nonIBD.csv", na.strings=c("", "NA"))

# Set Working Directory back to current folder
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
work_DIR <- getwd()

## Select a disorder to analyse (options; CD or UC)
disorder <- "CD"

if (disorder == "CD") {
  mSet = mSet_CD 
  print("Selected disorder is Crohn's disease")}else if(disorder == "UC"){ 
    mSet = mSet_UC
    print("Selected disorder is Ulcerative Colitis")}else{print("Disorder not Recognised")}
```

Second, we perform data extraction from the file, and process the data
```{r data_import,warning=FALSE, message=FALSE}
##DATA CLEANUP:
if(!"dplyr" %in% installed.packages()){install.packages("dplyr")}
library(dplyr)

#Update IDs To new HMDB structure
mSet_HMDB_NEW <- data.frame(lapply(mSet, function(x) {
                  gsub("HMDB", "HMDB00", x)
             }))

#Merge column headers: disorder_patientID
names(mSet_HMDB_NEW ) <- paste(mSet_HMDB_NEW [1, ], names(mSet_HMDB_NEW ), sep = "_")
mSet_HMDB_NEW <- mSet_HMDB_NEW [-1,]

##DATA PROCESSING:

#Remove metabolites with < 50% data (located in columns 8-553.
columns <- ncol(mSet_HMDB_NEW)
rowsData <- nrow(mSet_HMDB_NEW)
removeLines <- rowSums(is.na(mSet_HMDB_NEW[,2-columns]))
fifty_percent <- floor((columns)/2)

mSet_MissingDataCounted <- cbind(mSet_HMDB_NEW, removeLines)
mSet_NoMissingData <- subset(mSet_MissingDataCounted, removeLines <= fifty_percent)
#Remove last column for further processing.
mSet_NoMissingData <- subset(mSet_NoMissingData, select=-c(removeLines))

#Convert intensity data to numeric values                         
mSet_NoMissingData[, c(2:columns)] <- apply(mSet_NoMissingData[, c(2:columns)], 2, function(x) as.numeric(as.character(x)))

##normalization (see https://doi.org/10.1177%2F1469066720918446 and https://www.statology.org/transform-data-in-r/)
##Users can select different transformation styles here:
transformation <- "log_2" #log_2 transformation on intensity data selected for IBD dataset, options are: cube_root, square_root, log_2, log_10

if(transformation == "cube_root"){
    mSet_transformed <- cbind(mSet_NoMissingData[,c(1)], mSet_NoMissingData[,2:columns]^(1/3))
}else if(transformation == "square_root"){
    mSet_transformed <- cbind(mSet_NoMissingData[,c(1)], mSet_NoMissingData[,2:columns]^(1/2))
}else if(transformation == "log_2"){
    mSet_transformed <- cbind(mSet_NoMissingData[,c(1)], log2(mSet_NoMissingData[,2:columns]))
}else if(transformation == "log_10"){
    mSet_transformed <- cbind(mSet_NoMissingData[,c(1)], log10(mSet_NoMissingData[,2:columns]))
}else{print("Warning: name for transformation not recognized")}

colnames(mSet_transformed)[1]="HMDB.ID"

## Visualize the data after the transformation (for one sample to get an idea of suitability of transformation:
#create histogram for original distribution for first column with data
hist(mSet_NoMissingData[,2], col='steelblue', main='Original')
#create histogram for log-transformed distribution 
hist(mSet_transformed[,2], col='coral2', main=transformation)

## Testing if the transformation creates a normally distributed dataset (alpha >= 0.05)
##Calculate all Shapiro values for raw and transformed data:
mSet_NoMissingData_Shapiro <- lapply(mSet_NoMissingData[,2:columns], shapiro.test)
mSet_transformed_Shapiro <- lapply(mSet_transformed[,2:columns], shapiro.test)

#Obtain the p-values for raw and transformed data
mSet_NoMissingData_Shapiro_pvalues <- do.call(rbind, mSet_NoMissingData_Shapiro)
mSet_transformed_Shapiro_pvalues <- do.call(rbind, mSet_transformed_Shapiro)

## Count how often the p-value is above 0.05, to obtain an estimate of achieved normality due to transformation
mSet_NoMissingData_Shapiro_pvalues_sum <- sum(mSet_NoMissingData_Shapiro_pvalues[,2] >= 0.05, na.rm=TRUE)
mSet_transformed_Shapiro_pvalues_sum <- sum(mSet_transformed_Shapiro_pvalues[,2] >= 0.05, na.rm=TRUE)

eighty_percent <- floor(((columns)/10)*8)

#Print relevant information:
if(mSet_transformed_Shapiro_pvalues_sum[1] > eighty_percent ){paste0("Data after ", transformation ," transformation seems to follow a normal distribution for more then 80% of your data")} else{
  print("Advised to select a different data transformation procedure")}

remove(mSet_HMDB_NEW, mSet_MissingDataCounted, mSet_NoMissingData, mSet_NoMissingData_Shapiro, mSet_NoMissingData_Shapiro_pvalues, mSet_transformed_Shapiro, mSet_transformed_Shapiro_pvalues, eighty_percent, fifty_percent, mSet_NoMissingData_Shapiro_pvalues_sum, mSet_transformed_Shapiro_pvalues_sum, removeLines, columns, rowsData)
```

## Calculate logFC and p-value
```{r basic_statistics, warning=FALSE, message=FALSE}
#Create backup of data
mSet_transformed.b <- mSet_transformed
##Order columns based on disease abbreviation (located in column names); adding the control group nonIBD as last columns:
if (disorder == "CD") {
mSet_FINAL <- mSet_transformed[ , order(names(mSet_transformed))]}else{mSet_FINAL <- mSet_transformed[ , order(names(mSet_transformed), decreasing=TRUE)]}

##Move HMDB column back to the start
columnNumber <- which(colnames(mSet_FINAL)=="HMDB.ID")
mSet_FINAL <- mSet_FINAL[,c(columnNumber,1:ncol(mSet_FINAL)-1)]
mSet_FINAL <- mSet_FINAL [,-(columnNumber+1)]

#Find relevant columns per group.
library(stringr)
columns_disorders <- sum(str_count(colnames(mSet_FINAL), disorder))
end_Disorders <- (columns_disorders+1)

##calculate logFC for 2 groups (CD vs control, UC vs control), ignoring missing values (NAs) when calculating the mean.  
disease = apply(mSet_FINAL[,2:end_Disorders], 1, mean, na.rm=TRUE)
control_IBD = apply(mSet_FINAL[,(end_Disorders+1):ncol(mSet_FINAL)], 1, mean, na.rm=TRUE)

#because the metabolomics data is already log2 transformed, we need to take the difference between the means (iso dividing the means over one another), since log2 Fold Change or log2 Ratio == log2(control / condition). Note: if the transformation step applied is cube_root or square_root, one needs to divide control over disease for this step!

if(transformation == "log_2" | transformation == "log10"){
    foldchange_disorder <- control_IBD - disease
}else{
  foldchange_disorder <- (control_IBD / disease)}

##ADD HMDB column at start, add fold change columns.
mSet_AnalysisReady <- cbind(mSet_FINAL$HMDB.ID, foldchange_disorder)
##Rename first column
colnames(mSet_AnalysisReady)[1] <- "HMDB_ID"

##Calculate p-value for two groups based on t-test (comparing control to disease).
##general function to store p-values for multiple rows:
ttest_mSet <- function(df, grp1, grp2) {
  x = df[grp1]
  y = df[grp2]
  x = as.numeric(x)
  y = as.numeric(y)  
  results = t.test(x, y)
  results$p.value
}
p_values_disorder <- apply(mSet_FINAL, 1, ttest_mSet, grp1 = c(2:end_Disorders), grp2 = c((end_Disorders+1):ncol(mSet_FINAL)))

##Add p_values column to analysis dataset:
mSet_AnalysisReady <- cbind(mSet_AnalysisReady, p_values_disorder)

#Convert logFC and p-values columns to numeric values            
mSet_AnalysisReady <- as.data.frame(mSet_AnalysisReady)
mSet_AnalysisReady[ , c(2,3)] <- apply(mSet_AnalysisReady[ , c(2,3)], 2, function(x) as.numeric(as.character(x)))

remove(mSet_transformed, columns_disorders, columnNumber, end_Disorders, foldchange_disorder, p_values_disorder, control_IBD, disease, ttest_mSet, mSet_FINAL)
```


## Volcano plot
The next step will visualize relevant metabolites in a Volcano plot, with thresholds defined for the log2FCs and p-values.
Since we are dealing with nontargeted LC_MS data, we are applying stringent criteria here (p-value below 0.01, and |log2FC| >= 1.5)

```{r volcano_plot,warning=FALSE, message=FALSE}
##Inspired by: https://biocorecrg.github.io/CRG_RIntroduction/volcano-plots.html
if(!"ggplot2" %in% installed.packages()){install.packages("ggplot2")}
library('ggplot2')

##Define the thresholds for log2 (Fold Change) and p-values
#For cut-off value uncertainties, see https://doi.org/10.1039/C6AN01342B .
log2FC_min <- -1
log2FC_max <- 1
p_value_threshold <- 0.05

##Create column with HMDB_IDs, only if the data is relevant
mSet_AnalysisReady$relevant_labels <- mSet_AnalysisReady$HMDB_ID
mSet_AnalysisReady$relevant_labels[!((mSet_AnalysisReady$foldchange_disorder <= log2FC_min | mSet_AnalysisReady$foldchange_disorder >= log2FC_max) &  mSet_AnalysisReady$p_values_disorder <= p_value_threshold)] <- NA

# Library needed to space out the labels
if(!"ggrepel" %in% installed.packages()){install.packages("ggrepel")}
library(ggrepel)

##volcanoPlot_Disorder 
volcanoPlot_disorder <- ggplot(data=mSet_AnalysisReady, aes(x=foldchange_disorder, y=-log10(p_values_disorder), label=relevant_labels)) + geom_point() + theme_minimal() + geom_text_repel()

## Add vertical lines for FoldChange and P-value thresholds:
volcanoPlot_disorder <- volcanoPlot_disorder + geom_vline(xintercept=c(log2FC_min, log2FC_max), col="blue") +
    geom_hline(yintercept=-log10(p_value_threshold), col="red") + theme(plot.background = element_rect(fill = "white"))

if (disorder == "UC") {disorderName <- "Ulcerative Colitis (UC)"}else{disorderName <- "Crohn's disease (CD)"}

titleVolcano <- paste0("Volcano plot of ", transformation, " transformed data for ", disorderName )
verticalAxisTitle <- paste0(transformation, " Fold Change, control versus ", disorderName)

## Add title and update axis labels:
volcanoPlot_disorder <- volcanoPlot_disorder + ggtitle(titleVolcano) + labs(y = "-log10(p-value)", x = verticalAxisTitle)

##TODO: Add a title, change the axis labels:

# Show the Volcano plot in the notebook output:
volcanoPlot_disorder
```
Export the data and Volcano Plot:
```{r data_export, warning=FALSE, message=FALSE}
##Save the data file
nameDataFile <- paste0("output/mbxData_", disorder ,".csv")
write.table(mSet_AnalysisReady, nameDataFile, sep =",", row.names = FALSE)

if(!"svglite" %in% installed.packages()){install.packages("svglite")}
library('svglite')

##Save the Volcano plot:
imageType <- "png" ##Options are: svg, png, eps, ps, tex, pdf, jpeg, tiff, png, bmp, svg or wmf
nameVolcano <- paste0("output/", disorder, "_VolcanoPlot_absLogFC_", log2FC_max, "_pValue_", p_value_threshold, ".", imageType)

ggsave(nameVolcano)

```

